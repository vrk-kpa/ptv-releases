<#@ include file="OutputFile.ttinclude"#>
<#@ include file="Block.ttinclude"#>
<#@ include file="DynamicTextTransformation.ttinclude" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#+
    /// <summary>
    /// Responsible for marking the various sections of the generation,
    /// so they can be split up into separate files and projects
    /// </summary>
    public class TemplateFileManager
    {
        // reference to the GenerationEnvironment StringBuilder on the TextTransformation object
        private readonly StringBuilder _generationEnvironment;
        private Block currentBlock;
        private readonly List<Block> files = new List<Block>();
        private readonly Block footer = new Block();
        private readonly Block header = new Block();
        private readonly DynamicTextTransformation _textTransformation;
        private readonly string _outputDirectoryPath;
        private const int STANDARD_INDENT_LENGTH = 4;

        /// <summary>
        /// Defines Encoding format for generated output file. (Default UTF8)
        /// </summary>
        /// <returns></returns>
        public Encoding Encoding { get; set; }

        /// <summary>
        /// If set to false, existing files are not overwritten
        /// </summary>
        /// <returns></returns>
        public bool CanOverrideExistingFile { get; set; }

        /// <summary>
        /// Initializes an TemplateFileManager Instance  with the
        /// TextTransformation (T4 generated class) that is currently running
        /// </summary>
        private TemplateFileManager(object textTransformation, string outputDirectoryPath)
        {
            if (textTransformation == null)
            {
                throw new ArgumentNullException(nameof(textTransformation));
            }

            _outputDirectoryPath = outputDirectoryPath;
            _textTransformation = DynamicTextTransformation.Create(textTransformation);
            _generationEnvironment = _textTransformation.GenerationEnvironment;

            CanOverrideExistingFile = true;
            Encoding = Encoding.UTF8;
        }

        /// <summary>
        /// Marks the end of the last file if there was one, and starts a new
        /// and marks this point in generation as a new file.
        /// </summary>
        /// <param name="name">Filename</param>
        /// <param name="projectName">Name of the target project for the new file.</param>
        /// <param name="folderName">Name of the target folder for the new file.</param>
        /// <param name="fileProperties">File property settings in vs for the new File</param>
        public void StartNewFile(string name
            , string projectName = "", string folderName = "", FileProperties fileProperties = null)
        {
            if (String.IsNullOrWhiteSpace(name) == true)
            {
                throw new ArgumentException("name");
            }

            CurrentBlock = new Block
            {
                Name = name,
                ProjectName = projectName,
                FolderName = folderName,
                FileProperties = fileProperties ?? new FileProperties()
            };
        }

        /// <summary>
        /// Creates files with VS sync
        /// </summary>
        public static TemplateFileManager Create(object textTransformation, string outputDirectoryPath)
        {
            var transformation = DynamicTextTransformation.Create(textTransformation);
            return new TemplateFileManager(transformation, outputDirectoryPath);
        }

        public void EndBlock()
        {
            if (CurrentBlock == null)
            {
                return;
            }

            CurrentBlock.Length = _generationEnvironment.Length - CurrentBlock.Start;

            if (CurrentBlock != header && CurrentBlock != footer)
            {
                files.Add(CurrentBlock);
            }

            currentBlock = null;
        }

        /// <summary>
        /// Produce the template output files.
        /// </summary>
        public virtual IEnumerable<OutputFile> Process(bool split = true)
        {
            var list = new List<OutputFile>();

            if (!split)
            {
                return list;
            }

            EndBlock();

            var headerText = _generationEnvironment.ToString(header.Start, header.Length);
            var footerText = _generationEnvironment.ToString(footer.Start, footer.Length);
            files.Reverse();

            foreach (var block in files)
            {
                var fileName = Path.Combine(_outputDirectoryPath, block.Name);
                var content = this.ReplaceParameter(headerText, block) +
                              _generationEnvironment.ToString(block.Start, block.Length) +
                              footerText;

                var file = new OutputFile
                {
                    FileName = fileName,
                    ProjectName = block.ProjectName,
                    FolderName = block.FolderName,
                    FileProperties = block.FileProperties,
                    Content = content
                };

                CreateFile(file);
                _generationEnvironment.Remove(block.Start, block.Length);

                list.Add(file);
            }

            return list;
        }

        private string ReplaceParameter(string text, Block block)
        {
            if (!string.IsNullOrEmpty(text))
            {
                text = text.Replace("$filename$", block.Name);
            }

            return block.FileProperties.TemplateParameter.AsEnumerable()
                .Aggregate(text, (current, item) => current.Replace(item.Key, item.Value));
        }

        protected virtual void CreateFile(OutputFile file)
        {
            if (!CanOverrideExistingFile && File.Exists(file.FileName))
                return;

            if (!IsFileContentDifferent(file))
                return;

            File.WriteAllText(file.FileName, file.Content, this.Encoding);
        }

        private bool IsFileContentDifferent(OutputFile file)
        {
            return !(File.Exists(file.FileName) && File.ReadAllText(file.FileName) == file.Content);
        }

        private Block CurrentBlock
        {
            get => currentBlock;
            set
            {
                if (CurrentBlock != null)
                {
                    EndBlock();
                }

                if (value != null)
                {
                    value.Start = _generationEnvironment.Length;
                }

                currentBlock = value;
            }
        }        

        /// <summary>
        /// Get a string of spaces equivelent to the number of indents
        /// desired.
        /// </summary>
        public static string GetIndent(int indentLevel)
        {
            if (indentLevel < 0)
            {
                throw new ArgumentException("indentLevel");
            }

            return string.Empty.PadLeft(indentLevel * STANDARD_INDENT_LENGTH);
        }
    }
#>